

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Kramers-Kronig testing &mdash; pyimpspec 5.1.2 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="_static/plot_directive.css" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=2c218288"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
      <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Z-HIT analysis" href="apidocs_zhit.html" />
    <link rel="prev" title="Mock data" href="apidocs_mock_data.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            pyimpspec
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="guide.html">Getting started</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="apidocs.html">API Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="apidocs.html#pyimpspec.get_default_num_procs"><code class="docutils literal notranslate"><span class="pre">get_default_num_procs()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="apidocs.html#pyimpspec.set_default_num_procs"><code class="docutils literal notranslate"><span class="pre">set_default_num_procs()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="apidocs_data.html">Data parsing</a></li>
<li class="toctree-l2"><a class="reference internal" href="apidocs_mock_data.html">Mock data</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Kramers-Kronig testing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-pyimpspec">Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#pyimpspec.perform_kramers_kronig_test"><code class="docutils literal notranslate"><span class="pre">perform_kramers_kronig_test()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyimpspec.perform_exploratory_kramers_kronig_tests"><code class="docutils literal notranslate"><span class="pre">perform_exploratory_kramers_kronig_tests()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyimpspec.analysis.kramers_kronig.evaluate_log_F_ext"><code class="docutils literal notranslate"><span class="pre">evaluate_log_F_ext()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyimpspec.analysis.kramers_kronig.suggest_num_RC"><code class="docutils literal notranslate"><span class="pre">suggest_num_RC()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyimpspec.analysis.kramers_kronig.suggest_num_RC_limits"><code class="docutils literal notranslate"><span class="pre">suggest_num_RC_limits()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyimpspec.analysis.kramers_kronig.suggest_representation"><code class="docutils literal notranslate"><span class="pre">suggest_representation()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyimpspec.analysis.kramers_kronig.algorithms.suggest_num_RC_method_1"><code class="docutils literal notranslate"><span class="pre">suggest_num_RC_method_1()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyimpspec.analysis.kramers_kronig.algorithms.suggest_num_RC_method_2"><code class="docutils literal notranslate"><span class="pre">suggest_num_RC_method_2()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyimpspec.analysis.kramers_kronig.algorithms.suggest_num_RC_method_3"><code class="docutils literal notranslate"><span class="pre">suggest_num_RC_method_3()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyimpspec.analysis.kramers_kronig.algorithms.suggest_num_RC_method_4"><code class="docutils literal notranslate"><span class="pre">suggest_num_RC_method_4()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyimpspec.analysis.kramers_kronig.algorithms.suggest_num_RC_method_5"><code class="docutils literal notranslate"><span class="pre">suggest_num_RC_method_5()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyimpspec.analysis.kramers_kronig.algorithms.suggest_num_RC_method_6"><code class="docutils literal notranslate"><span class="pre">suggest_num_RC_method_6()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyimpspec.analysis.kramers_kronig.algorithms.utility.calculate_curvatures"><code class="docutils literal notranslate"><span class="pre">calculate_curvatures()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#pyimpspec.analysis.kramers_kronig.algorithms.utility.subdivide_frequencies"><code class="docutils literal notranslate"><span class="pre">subdivide_frequencies()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-1">Class</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#pyimpspec.KramersKronigResult"><code class="docutils literal notranslate"><span class="pre">KramersKronigResult</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="apidocs_zhit.html">Z-HIT analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="apidocs_drt.html">Distribution of relaxation times</a></li>
<li class="toctree-l2"><a class="reference internal" href="apidocs_circuit.html">Equivalent circuits</a></li>
<li class="toctree-l2"><a class="reference internal" href="apidocs_fitting.html">Circuit fitting</a></li>
<li class="toctree-l2"><a class="reference internal" href="apidocs_plot_mpl.html">Plotting - matplotlib</a></li>
<li class="toctree-l2"><a class="reference internal" href="apidocs_typing.html">Typing</a></li>
<li class="toctree-l2"><a class="reference internal" href="apidocs_exceptions.html">Exceptions</a></li>
<li class="toctree-l2"><a class="reference internal" href="apidocs_progress.html">Progress</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pyimpspec</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="apidocs.html">API Documentation</a></li>
      <li class="breadcrumb-item active">Kramers-Kronig testing</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/apidocs_kramers_kronig.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="kramers-kronig-testing">
<h1>Kramers-Kronig testing<a class="headerlink" href="#kramers-kronig-testing" title="Link to this heading"></a></h1>
<p>A collection of functions and classes for performing Kramers-Kronig tests on data sets.</p>
<section id="module-pyimpspec">
<span id="functions"></span><h2>Functions<a class="headerlink" href="#module-pyimpspec" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="pyimpspec.perform_kramers_kronig_test">
<span class="sig-prename descclassname"><span class="pre">pyimpspec.</span></span><span class="sig-name descname"><span class="pre">perform_kramers_kronig_test</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">test</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'real'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_RC</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">add_capacitance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">add_inductance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">admittance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_log_F_ext</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_log_F_ext</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log_F_ext</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_F_ext_evaluations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rapid_F_ext_evaluations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cnls_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'leastsq'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_nfev</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">60</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_procs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyimpspec.perform_kramers_kronig_test" title="Link to this definition"></a></dt>
<dd><p>Performs linear Kramers-Kronig tests, attempts to automatically find a suitable extension of the time constant range, optionally suggests the appropriate immittance representation to test, and automatically suggests the optimal number of RC elements to use.
The results can be used to check the validity of an impedance spectrum before performing equivalent circuit fitting.
This function acts as a wrapper for <a class="reference internal" href="#pyimpspec.analysis.kramers_kronig.evaluate_log_F_ext" title="pyimpspec.analysis.kramers_kronig.evaluate_log_F_ext"><code class="xref py py-func docutils literal notranslate"><span class="pre">evaluate_log_F_ext()</span></code></a>, <a class="reference internal" href="#pyimpspec.analysis.kramers_kronig.suggest_num_RC_limits" title="pyimpspec.analysis.kramers_kronig.suggest_num_RC_limits"><code class="xref py py-func docutils literal notranslate"><span class="pre">suggest_num_RC_limits()</span></code></a>, <a class="reference internal" href="#pyimpspec.analysis.kramers_kronig.suggest_num_RC" title="pyimpspec.analysis.kramers_kronig.suggest_num_RC"><code class="xref py py-func docutils literal notranslate"><span class="pre">suggest_num_RC()</span></code></a>, and <a class="reference internal" href="#pyimpspec.analysis.kramers_kronig.suggest_representation" title="pyimpspec.analysis.kramers_kronig.suggest_representation"><code class="xref py py-func docutils literal notranslate"><span class="pre">suggest_representation()</span></code></a>.</p>
<p>References:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://doi.org/10.1149/1.2044210">B.A. Boukamp, 1995, J. Electrochem. Soc., 142, 1885-1894</a></p></li>
<li><p><a class="reference external" href="https://doi.org/10.1016/j.electacta.2014.01.034">M. Schönleber, D. Klotz, and E. Ivers-Tiffée, 2014, Electrochim. Acta, 131, 20-27</a></p></li>
<li><p><a class="reference external" href="https://doi.org/10.1109/IWIS57888.2022.9975131">C. Plank, T. Rüther, and M.A. Danzer, 2022, 2022 International Workshop on Impedance Spectroscopy (IWIS), 1-6</a></p></li>
<li><p><a class="reference external" href="https://doi.org/10.1016/j.electacta.2024.144951">V. Yrjänä and J. Bobacka, 2024, Electrochim. Acta, 504, 144951</a></p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<a class="reference internal" href="apidocs_data.html#pyimpspec.DataSet" title="pyimpspec.DataSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataSet</span></code></a>) – The data set to be tested.</p></li>
<li><p><strong>test</strong> (<em>str</em><em>, </em><em>optional</em>) – Supported values include “complex”, “imaginary”, “real”, “complex-inv”, “imaginary-inv”, “real-inv”, and “cnls”.
The first three correspond to the complex, imaginary, real tests, respectively, described by Boukamp (1995).
These three implementations use least squares fitting (see <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.linalg.lstsq.html">numpy.linalg.lstsq</a>).
The implementations ending with “-inv” use matrix inversion, which was the default in pyimpspec prior to version 5.0.0.
The “cnls” implementation uses complex non-linear least squares fitting.</p></li>
<li><p><strong>num_RC</strong> (<em>int</em><em>, </em><em>optional</em>) – The number of RC elements to use.
A value greater than or equal to one results in the specific number of RC elements being tested.
Otherwise, the number of RC elements is determined automatically.</p></li>
<li><p><strong>add_capacitance</strong> (<em>bool</em><em>, </em><em>optional</em>) – Add an additional capacitance in series (or in parallel if <code class="docutils literal notranslate"><span class="pre">admittance=True</span></code>) with the rest of the circuit.</p></li>
<li><p><strong>add_inductance</strong> (<em>bool</em><em>, </em><em>optional</em>) – Add an additional inductance in series (or in parallel if <code class="docutils literal notranslate"><span class="pre">admittance=True</span></code>) with the rest of the circuit.</p></li>
<li><p><strong>admittance</strong> (<em>Optional</em><em>[</em><em>bool</em><em>]</em><em>, </em><em>optional</em>) – If True, then perform the test(s) using the admittance data (<span class="math notranslate nohighlight">\(Y = \frac{1}{Z}\)</span>) instead of the impedance data (<span class="math notranslate nohighlight">\(Z\)</span>).
Each representation uses a different equivalent circuit model: Fig. 1 for impedance and Fig. 13 for admittance (Boukamp, 1995).
Operating on the admittance data may be necessary in some cases such as when there is a negative differential resistance.
If set to None, then both representations are used and the <a class="reference internal" href="#pyimpspec.analysis.kramers_kronig.suggest_representation" title="pyimpspec.analysis.kramers_kronig.suggest_representation"><code class="xref py py-func docutils literal notranslate"><span class="pre">suggest_representation()</span></code></a> is used to pick one.</p></li>
<li><p><strong>min_log_F_ext</strong> (<em>float</em><em>, </em><em>optional</em>) – The lower limit for <span class="math notranslate nohighlight">\(\log{F_{\rm ext}}\)</span>, which extends or contracts the range of time constants.</p></li>
<li><p><strong>max_log_F_ext</strong> (<em>float</em><em>, </em><em>optional</em>) – The upper limit for <span class="math notranslate nohighlight">\(\log{F_{\rm ext}}\)</span>, which extends or contracts the range of time constants.</p></li>
<li><p><strong>log_F_ext</strong> (<em>float</em><em>, </em><em>optional</em>) – If <code class="docutils literal notranslate"><span class="pre">num_F_ext_evaluations</span> <span class="pre">==</span> <span class="pre">0</span></code>, then <code class="docutils literal notranslate"><span class="pre">log_F_ext</span></code> is used directly as the value for <span class="math notranslate nohighlight">\(\log{F_{\rm ext}}\)</span>.</p></li>
<li><p><strong>num_F_ext_evaluations</strong> (<em>int</em><em>, </em><em>optional</em>) – The maximum number of evaluations to perform when trying to automatically estimate the optimal <span class="math notranslate nohighlight">\(\log{F_{\rm ext}}\)</span>.
Values greater than zero cause an approach based on splitting the range of logarithmic extensions into evenly spaced parts, estimating where the minimum is, and evaluating additional points near that minimum.
Values less than zero cause an approach based on using the differential evolution algorithm to find the minimum.
A value of zero causes <code class="docutils literal notranslate"><span class="pre">log_F_ext</span></code> to be used directly as <span class="math notranslate nohighlight">\(\log{F_{\rm ext}}\)</span>.</p></li>
<li><p><strong>rapid_F_ext_evaluations</strong> (<em>bool</em><em>, </em><em>optional</em>) – If possible, minimize the number of time constants that are tested when evaluating extensions in order to perform the optimization faster.</p></li>
<li><p><strong>cnls_method</strong> (<em>str</em><em>, </em><em>optional</em>) – The iterative method used to perform the fitting.
Only relevant when performing “cnls” tests.</p></li>
<li><p><strong>max_nfev</strong> (<em>int</em><em>, </em><em>optional</em>) – The maximum number of function evaluations.
If less than one, then no limit is imposed.
Only relevant when performing “cnls” tests.</p></li>
<li><p><strong>timeout</strong> (<em>int</em><em>, </em><em>optional</em>) – The maximum amount of time in seconds to spend performing tests.
Only relevant when performing “cnls” tests.</p></li>
<li><p><strong>num_procs</strong> (<em>int</em><em>, </em><em>optional</em>) – The number of parallel processes to use when performing tests.
Only relevant when performing “cnls” tests.</p></li>
<li><p><strong>**kwargs</strong> – Additional keyword arguments are passed on to the algorithms that are used when automatically determining an optimal number of RC elements.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A single linear Kramers-Kronig test result representing the suggested extension of the range of time constants, the suggested number of RC elements (i.e., time constants), and the suggested representation of the immittance spectrum to test.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#pyimpspec.KramersKronigResult" title="pyimpspec.KramersKronigResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">KramersKronigResult</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function" id="module-0">
<dt class="sig sig-object py" id="pyimpspec.perform_exploratory_kramers_kronig_tests">
<span class="sig-prename descclassname"><span class="pre">pyimpspec.</span></span><span class="sig-name descname"><span class="pre">perform_exploratory_kramers_kronig_tests</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">test</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'real'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_RCs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">add_capacitance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">add_inductance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">admittance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_log_F_ext</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_log_F_ext</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log_F_ext</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_F_ext_evaluations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rapid_F_ext_evaluations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cnls_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'leastsq'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_nfev</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">60</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_procs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyimpspec.perform_exploratory_kramers_kronig_tests" title="Link to this definition"></a></dt>
<dd><p>Similar to <a class="reference internal" href="#pyimpspec.perform_kramers_kronig_test" title="pyimpspec.perform_kramers_kronig_test"><code class="xref py py-func docutils literal notranslate"><span class="pre">perform_kramers_kronig_test()</span></code></a> but returns some intermediate results rather than only the final <a class="reference internal" href="#pyimpspec.KramersKronigResult" title="pyimpspec.KramersKronigResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">KramersKronigResult</span></code></a>.
This function acts as a wrapper for <a class="reference internal" href="#pyimpspec.analysis.kramers_kronig.evaluate_log_F_ext" title="pyimpspec.analysis.kramers_kronig.evaluate_log_F_ext"><code class="xref py py-func docutils literal notranslate"><span class="pre">evaluate_log_F_ext()</span></code></a>, <a class="reference internal" href="#pyimpspec.analysis.kramers_kronig.suggest_num_RC" title="pyimpspec.analysis.kramers_kronig.suggest_num_RC"><code class="xref py py-func docutils literal notranslate"><span class="pre">suggest_num_RC()</span></code></a>, and <a class="reference internal" href="#pyimpspec.analysis.kramers_kronig.suggest_representation" title="pyimpspec.analysis.kramers_kronig.suggest_representation"><code class="xref py py-func docutils literal notranslate"><span class="pre">suggest_representation()</span></code></a>.</p>
<p>References:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://doi.org/10.1149/1.2044210">B.A. Boukamp, 1995, J. Electrochem. Soc., 142, 1885-1894</a></p></li>
<li><p><a class="reference external" href="https://doi.org/10.1016/j.electacta.2014.01.034">M. Schönleber, D. Klotz, and E. Ivers-Tiffée, 2014, Electrochim. Acta, 131, 20-27</a></p></li>
<li><p><a class="reference external" href="https://doi.org/10.1109/IWIS57888.2022.9975131">C. Plank, T. Rüther, and M.A. Danzer, 2022, 2022 International Workshop on Impedance Spectroscopy (IWIS), 1-6</a></p></li>
<li><p><a class="reference external" href="https://doi.org/10.1016/j.electacta.2024.144951">V. Yrjänä and J. Bobacka, 2024, Electrochim. Acta, 504, 144951</a></p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<a class="reference internal" href="apidocs_data.html#pyimpspec.DataSet" title="pyimpspec.DataSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataSet</span></code></a>) – The data set to be tested.</p></li>
<li><p><strong>test</strong> (<em>str</em><em>, </em><em>optional</em>) – See <a class="reference internal" href="#pyimpspec.perform_kramers_kronig_test" title="pyimpspec.perform_kramers_kronig_test"><code class="xref py py-func docutils literal notranslate"><span class="pre">perform_kramers_kronig_test()</span></code></a> for details.</p></li>
<li><p><strong>num_RCs</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>int</em><em>]</em><em>]</em><em>, </em><em>optional</em>) – A list of integers of the various numbers of RC elements to test.
If a None value is provided (i.e., the default), then the range of values to test is determined automatically.</p></li>
<li><p><strong>add_capacitance</strong> (<em>bool</em><em>, </em><em>optional</em>) – See <a class="reference internal" href="#pyimpspec.perform_kramers_kronig_test" title="pyimpspec.perform_kramers_kronig_test"><code class="xref py py-func docutils literal notranslate"><span class="pre">perform_kramers_kronig_test()</span></code></a> for details.</p></li>
<li><p><strong>add_inductance</strong> (<em>bool</em><em>, </em><em>optional</em>) – See <a class="reference internal" href="#pyimpspec.perform_kramers_kronig_test" title="pyimpspec.perform_kramers_kronig_test"><code class="xref py py-func docutils literal notranslate"><span class="pre">perform_kramers_kronig_test()</span></code></a> for details.</p></li>
<li><p><strong>admittance</strong> (<em>bool</em><em>, </em><em>optional</em>) – See <a class="reference internal" href="#pyimpspec.perform_kramers_kronig_test" title="pyimpspec.perform_kramers_kronig_test"><code class="xref py py-func docutils literal notranslate"><span class="pre">perform_kramers_kronig_test()</span></code></a> for details.</p></li>
<li><p><strong>min_log_F_ext</strong> (<em>float</em><em>, </em><em>optional</em>) – See <a class="reference internal" href="#pyimpspec.perform_kramers_kronig_test" title="pyimpspec.perform_kramers_kronig_test"><code class="xref py py-func docutils literal notranslate"><span class="pre">perform_kramers_kronig_test()</span></code></a> for details.</p></li>
<li><p><strong>max_log_F_ext</strong> (<em>float</em><em>, </em><em>optional</em>) – See <a class="reference internal" href="#pyimpspec.perform_kramers_kronig_test" title="pyimpspec.perform_kramers_kronig_test"><code class="xref py py-func docutils literal notranslate"><span class="pre">perform_kramers_kronig_test()</span></code></a> for details.</p></li>
<li><p><strong>log_F_ext</strong> (<em>float</em><em>, </em><em>optional</em>) – See <a class="reference internal" href="#pyimpspec.perform_kramers_kronig_test" title="pyimpspec.perform_kramers_kronig_test"><code class="xref py py-func docutils literal notranslate"><span class="pre">perform_kramers_kronig_test()</span></code></a> for details.</p></li>
<li><p><strong>num_F_ext_evaluations</strong> (<em>int</em><em>, </em><em>optional</em>) – See <a class="reference internal" href="#pyimpspec.perform_kramers_kronig_test" title="pyimpspec.perform_kramers_kronig_test"><code class="xref py py-func docutils literal notranslate"><span class="pre">perform_kramers_kronig_test()</span></code></a> for details.</p></li>
<li><p><strong>rapid_F_ext_evaluations</strong> (<em>bool</em><em>, </em><em>optional</em>) – See <a class="reference internal" href="#pyimpspec.perform_kramers_kronig_test" title="pyimpspec.perform_kramers_kronig_test"><code class="xref py py-func docutils literal notranslate"><span class="pre">perform_kramers_kronig_test()</span></code></a> for details.</p></li>
<li><p><strong>cnls_method</strong> (<em>str</em><em>, </em><em>optional</em>) – See <a class="reference internal" href="#pyimpspec.perform_kramers_kronig_test" title="pyimpspec.perform_kramers_kronig_test"><code class="xref py py-func docutils literal notranslate"><span class="pre">perform_kramers_kronig_test()</span></code></a> for details.</p></li>
<li><p><strong>max_nfev</strong> (<em>int</em><em>, </em><em>optional</em>) – See <a class="reference internal" href="#pyimpspec.perform_kramers_kronig_test" title="pyimpspec.perform_kramers_kronig_test"><code class="xref py py-func docutils literal notranslate"><span class="pre">perform_kramers_kronig_test()</span></code></a> for details.</p></li>
<li><p><strong>timeout</strong> (<em>int</em><em>, </em><em>optional</em>) – See <a class="reference internal" href="#pyimpspec.perform_kramers_kronig_test" title="pyimpspec.perform_kramers_kronig_test"><code class="xref py py-func docutils literal notranslate"><span class="pre">perform_kramers_kronig_test()</span></code></a> for details.</p></li>
<li><p><strong>num_procs</strong> (<em>int</em><em>, </em><em>optional</em>) – See <a class="reference internal" href="#pyimpspec.perform_kramers_kronig_test" title="pyimpspec.perform_kramers_kronig_test"><code class="xref py py-func docutils literal notranslate"><span class="pre">perform_kramers_kronig_test()</span></code></a> for details.</p></li>
<li><p><strong>**kwargs</strong> – See <a class="reference internal" href="#pyimpspec.perform_kramers_kronig_test" title="pyimpspec.perform_kramers_kronig_test"><code class="xref py py-func docutils literal notranslate"><span class="pre">perform_kramers_kronig_test()</span></code></a> for details.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tuple containing a list of <a class="reference internal" href="#pyimpspec.KramersKronigResult" title="pyimpspec.KramersKronigResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">KramersKronigResult</span></code></a> and the corresponding result of <a class="reference internal" href="#pyimpspec.analysis.kramers_kronig.suggest_num_RC" title="pyimpspec.analysis.kramers_kronig.suggest_num_RC"><code class="xref py py-func docutils literal notranslate"><span class="pre">suggest_num_RC()</span></code></a> for the suggested extension of the range of time constants and the suggested representation of the immittance spectrum to test.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Tuple[List[<a class="reference internal" href="#pyimpspec.KramersKronigResult" title="pyimpspec.KramersKronigResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">KramersKronigResult</span></code></a>], Tuple[<a class="reference internal" href="#pyimpspec.KramersKronigResult" title="pyimpspec.KramersKronigResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">KramersKronigResult</span></code></a>, Dict[int, float], int, int]]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function" id="module-pyimpspec.analysis.kramers_kronig">
<dt class="sig sig-object py" id="pyimpspec.analysis.kramers_kronig.evaluate_log_F_ext">
<span class="sig-prename descclassname"><span class="pre">pyimpspec.analysis.kramers_kronig.</span></span><span class="sig-name descname"><span class="pre">evaluate_log_F_ext</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">test</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'real'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_RCs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">add_capacitance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">add_inductance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">admittance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_log_F_ext</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_log_F_ext</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log_F_ext</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_F_ext_evaluations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rapid_F_ext_evaluations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cnls_method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'leastsq'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_nfev</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">60</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_procs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyimpspec.analysis.kramers_kronig.evaluate_log_F_ext" title="Link to this definition"></a></dt>
<dd><p>Evaluates extensions (or contractions) of the range of time constants in order to find an optimum.
Linear Kramers-Kronig tests are performed at various ranges of time constants.
The limits of the default range are defined by the reciprocals of the maximum and minimum excitation frequencies.
The lower and upper limits of the extended (or contracted) ranges are defined as <span class="math notranslate nohighlight">\(\tau_{\rm min} = 1/(F_{\rm ext}\omega_{\rm max})\)</span> and <span class="math notranslate nohighlight">\(\tau_{\rm max} = F_{\rm ext}/\omega_{\rm min}\)</span>, respectively.</p>
<p>References:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://doi.org/10.1016/j.electacta.2024.144951">V. Yrjänä and J. Bobacka, 2024, Electrochim. Acta, 504, 144951</a></p></li>
<li><p><a class="reference external" href="https://doi.org/10.1149/1.2044210">B.A. Boukamp, 1995, J. Electrochem. Soc., 142, 1885-1894</a></p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<a class="reference internal" href="apidocs_data.html#pyimpspec.DataSet" title="pyimpspec.DataSet"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataSet</span></code></a>) – The data set to be tested.</p></li>
<li><p><strong>test</strong> (<em>str</em><em>, </em><em>optional</em>) – See <a class="reference internal" href="#pyimpspec.perform_kramers_kronig_test" title="pyimpspec.perform_kramers_kronig_test"><code class="xref py py-func docutils literal notranslate"><span class="pre">perform_kramers_kronig_test()</span></code></a> for details.</p></li>
<li><p><strong>num_RCs</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>int</em><em>]</em><em>]</em><em>, </em><em>optional</em>) – See <a class="reference internal" href="#pyimpspec.perform_exploratory_kramers_kronig_tests" title="pyimpspec.perform_exploratory_kramers_kronig_tests"><code class="xref py py-func docutils literal notranslate"><span class="pre">perform_exploratory_kramers_kronig_tests()</span></code></a> for details.</p></li>
<li><p><strong>add_capacitance</strong> (<em>bool</em><em>, </em><em>optional</em>) – See <a class="reference internal" href="#pyimpspec.perform_kramers_kronig_test" title="pyimpspec.perform_kramers_kronig_test"><code class="xref py py-func docutils literal notranslate"><span class="pre">perform_kramers_kronig_test()</span></code></a> for details.</p></li>
<li><p><strong>add_inductance</strong> (<em>bool</em><em>, </em><em>optional</em>) – See <a class="reference internal" href="#pyimpspec.perform_kramers_kronig_test" title="pyimpspec.perform_kramers_kronig_test"><code class="xref py py-func docutils literal notranslate"><span class="pre">perform_kramers_kronig_test()</span></code></a> for details.</p></li>
<li><p><strong>admittance</strong> (<em>bool</em><em>, </em><em>optional</em>) – Perform the linear Kramers-Kronig test on the admittance representation instead of the impedance representation.</p></li>
<li><p><strong>min_log_F_ext</strong> (<em>float</em><em>, </em><em>optional</em>) – See <a class="reference internal" href="#pyimpspec.perform_kramers_kronig_test" title="pyimpspec.perform_kramers_kronig_test"><code class="xref py py-func docutils literal notranslate"><span class="pre">perform_kramers_kronig_test()</span></code></a> for details.</p></li>
<li><p><strong>max_log_F_ext</strong> (<em>float</em><em>, </em><em>optional</em>) – See <a class="reference internal" href="#pyimpspec.perform_kramers_kronig_test" title="pyimpspec.perform_kramers_kronig_test"><code class="xref py py-func docutils literal notranslate"><span class="pre">perform_kramers_kronig_test()</span></code></a> for details.</p></li>
<li><p><strong>log_F_ext</strong> (<em>float</em><em>, </em><em>optional</em>) – See <a class="reference internal" href="#pyimpspec.perform_kramers_kronig_test" title="pyimpspec.perform_kramers_kronig_test"><code class="xref py py-func docutils literal notranslate"><span class="pre">perform_kramers_kronig_test()</span></code></a> for details.</p></li>
<li><p><strong>num_F_ext_evaluations</strong> (<em>int</em><em>, </em><em>optional</em>) – See <a class="reference internal" href="#pyimpspec.perform_kramers_kronig_test" title="pyimpspec.perform_kramers_kronig_test"><code class="xref py py-func docutils literal notranslate"><span class="pre">perform_kramers_kronig_test()</span></code></a> for details.</p></li>
<li><p><strong>rapid_F_ext_evaluations</strong> (<em>bool</em><em>, </em><em>optional</em>) – See <a class="reference internal" href="#pyimpspec.perform_kramers_kronig_test" title="pyimpspec.perform_kramers_kronig_test"><code class="xref py py-func docutils literal notranslate"><span class="pre">perform_kramers_kronig_test()</span></code></a> for details.</p></li>
<li><p><strong>cnls_method</strong> (<em>str</em><em>, </em><em>optional</em>) – See <a class="reference internal" href="#pyimpspec.perform_kramers_kronig_test" title="pyimpspec.perform_kramers_kronig_test"><code class="xref py py-func docutils literal notranslate"><span class="pre">perform_kramers_kronig_test()</span></code></a> for details.</p></li>
<li><p><strong>max_nfev</strong> (<em>int</em><em>, </em><em>optional</em>) – See <a class="reference internal" href="#pyimpspec.perform_kramers_kronig_test" title="pyimpspec.perform_kramers_kronig_test"><code class="xref py py-func docutils literal notranslate"><span class="pre">perform_kramers_kronig_test()</span></code></a> for details.</p></li>
<li><p><strong>timeout</strong> (<em>int</em><em>, </em><em>optional</em>) – See <a class="reference internal" href="#pyimpspec.perform_kramers_kronig_test" title="pyimpspec.perform_kramers_kronig_test"><code class="xref py py-func docutils literal notranslate"><span class="pre">perform_kramers_kronig_test()</span></code></a> for details.</p></li>
<li><p><strong>num_procs</strong> (<em>int</em><em>, </em><em>optional</em>) – See <a class="reference internal" href="#pyimpspec.perform_kramers_kronig_test" title="pyimpspec.perform_kramers_kronig_test"><code class="xref py py-func docutils literal notranslate"><span class="pre">perform_kramers_kronig_test()</span></code></a> for details.</p></li>
<li><p><strong>**kwargs</strong></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>A list of tuples containing:</p>
<ul class="simple">
<li><p>The extension in terms of decades beyond the default range.</p></li>
<li><p>A list of linear Kramers-Kronig test results performed with a different number of RC elements (i.e., time constants).</p></li>
<li><p>The statistic indicating the quality of the extension (the smaller the better).</p></li>
</ul>
<p>The list of tuples is sorted from best to worst. The list of <a class="reference internal" href="#pyimpspec.KramersKronigResult" title="pyimpspec.KramersKronigResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">KramersKronigResult</span></code></a> instances within each tuple is sorted from lowest to highest number of RC elements, and the optimal number of RC elements still needs to be determined.</p>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>List[Tuple[float, List[<a class="reference internal" href="#pyimpspec.KramersKronigResult" title="pyimpspec.KramersKronigResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">KramersKronigResult</span></code></a>], float]]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyimpspec.analysis.kramers_kronig.suggest_num_RC">
<span class="sig-prename descclassname"><span class="pre">pyimpspec.analysis.kramers_kronig.</span></span><span class="sig-name descname"><span class="pre">suggest_num_RC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tests</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limit_delta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">methods</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_mean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_ranking</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_sum</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyimpspec.analysis.kramers_kronig.suggest_num_RC" title="Link to this definition"></a></dt>
<dd><p>Suggest the optimal number of RC elements to use as part of the linear Kramers-Kronig test by applying one or more of the following methods:</p>
<ul class="simple">
<li><p>1: <span class="math notranslate nohighlight">\(\mu\)</span>-criterion (Schönleber et al., 2014). With optional modifications that are enabled by default (Yrjänä and Bobacka, 2024).</p></li>
<li><p>2: The norm of the fitted variables (Plank et al., 2022).</p></li>
<li><p>3: The norm of the curvatures across the fitted impedance spectrum (Plank et al., 2022). With optional modifications that are enabled by default (Yrjänä and Bobacka, 2024).</p></li>
<li><p>4: The number of sign changes across the curvatures of the fitted impedance spectrum (Plank et al., 2022). With optional modifications that are enabled by default (Yrjänä and Bobacka, 2024).</p></li>
<li><p>5: The mean distance between sign changes across the curvatures of the fitted impedance spectrum (Yrjänä and Bobacka, 2024).</p></li>
<li><p>6: The apex of a <span class="math notranslate nohighlight">\(\log{\Sigma_{k=1}^{N_\tau} |\tau_k / R_k|}\)</span> (or <span class="math notranslate nohighlight">\(\log{\Sigma_{k=1}^{N_\tau} |\tau_k / C_k|}\)</span>) versus the number of RC elements (Yrjänä and Bobacka, 2024).</p></li>
</ul>
<p>If multiple methods are used, then one of several approaches can be used to determine which number of RC elements to suggest:</p>
<ul class="simple">
<li><p>Each method suggests a number of RC elements and the mean is chosen.</p></li>
<li><p>Each method ranks the different numbers of RC elements, exponentially decreasing points are assigned based on rank, the points assigned by each method are summed up, and the highest-scoring number of RC elements is chosen.</p></li>
<li><p>Each method returns a relative score from 0.0 to 1.0 (worst to best), the relative scores are added up, and the highest-scoring number of RC elements is chosen.</p></li>
</ul>
<p>If no methods are chosen, then the default approach is used:</p>
<ul class="simple">
<li><p>Use method 4 to obtain an initial list of candidates.</p></li>
<li><p>Use method 3 to reduce the list of candidates.</p></li>
<li><p>Use method 5 to reduce the list of candidates, if necessary.</p></li>
<li><p>Use <span class="math notranslate nohighlight">\(\chi^2_{\rm ps}\)</span> to reduce the list of candidates, if necessary.</p></li>
<li><p>Try to find a lower number of RC elements with a lower <span class="math notranslate nohighlight">\(\chi^2_{\rm ps}\)</span> and an equal number or fewer sign changes among the curvatures.</p></li>
</ul>
<p>If the lower and/or upper limit is not specified, then <a class="reference internal" href="#pyimpspec.analysis.kramers_kronig.suggest_num_RC_limits" title="pyimpspec.analysis.kramers_kronig.suggest_num_RC_limits"><code class="xref py py-func docutils literal notranslate"><span class="pre">suggest_num_RC_limits()</span></code></a> is used to estimate the limit(s).</p>
<p>References:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://doi.org/10.1016/j.electacta.2014.01.034">M. Schönleber, D. Klotz, and E. Ivers-Tiffée, 2014, Electrochim. Acta, 131, 20-27</a></p></li>
<li><p><a class="reference external" href="https://doi.org/10.1109/IWIS57888.2022.9975131">C. Plank, T. Rüther, and M.A. Danzer, 2022, 2022 International Workshop on Impedance Spectroscopy (IWIS), 1-6</a></p></li>
<li><p><a class="reference external" href="https://doi.org/10.1016/j.electacta.2024.144951">V. Yrjänä and J. Bobacka, 2024, Electrochim. Acta, 504, 144951</a></p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tests</strong> (List[<a class="reference internal" href="#pyimpspec.KramersKronigResult" title="pyimpspec.KramersKronigResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">KramersKronigResult</span></code></a>]) – The test results to evaluate.</p></li>
<li><p><strong>lower_limit</strong> (<em>int</em><em>, </em><em>optional</em>) – See <a class="reference internal" href="#pyimpspec.analysis.kramers_kronig.suggest_num_RC_limits" title="pyimpspec.analysis.kramers_kronig.suggest_num_RC_limits"><code class="xref py py-func docutils literal notranslate"><span class="pre">suggest_num_RC_limits()</span></code></a> for details.</p></li>
<li><p><strong>upper_limit</strong> (<em>int</em><em>, </em><em>optional</em>) – See <a class="reference internal" href="#pyimpspec.analysis.kramers_kronig.suggest_num_RC_limits" title="pyimpspec.analysis.kramers_kronig.suggest_num_RC_limits"><code class="xref py py-func docutils literal notranslate"><span class="pre">suggest_num_RC_limits()</span></code></a> for details.</p></li>
<li><p><strong>limit_delta</strong> (<em>int</em><em>, </em><em>optional</em>) – See <a class="reference internal" href="#pyimpspec.analysis.kramers_kronig.suggest_num_RC_limits" title="pyimpspec.analysis.kramers_kronig.suggest_num_RC_limits"><code class="xref py py-func docutils literal notranslate"><span class="pre">suggest_num_RC_limits()</span></code></a> for details.</p></li>
<li><p><strong>methods</strong> (<em>Optional</em><em>[</em><em>List</em><em>[</em><em>int</em><em>]</em><em>]</em><em>, </em><em>optional</em>) – A list of integers corresponding to the supported methods.</p></li>
<li><p><strong>use_mean</strong> (<em>bool</em><em>, </em><em>optional</em>) – If true, then the mean value of the number of RC elements suggested by each of the selected methods is chosen.</p></li>
<li><p><strong>use_ranking</strong> (<em>bool</em><em>, </em><em>optional</em>) – If true, then each selected method ranks the numbers of RC elements, a score is assigned based on ranking, and the highest-scoring number of RC elements is chosen.</p></li>
<li><p><strong>use_sum</strong> (<em>bool</em><em>, </em><em>optional</em>) – If true, then the scores returned by each of the selected methods are summed up and the highest-scoring number of RC elements is chosen.</p></li>
<li><p><strong>**kwargs</strong> – Keyword arguments are passed on to the underlying methods.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>A tuple containing:</p>
<ul class="simple">
<li><p>The <a class="reference internal" href="#pyimpspec.KramersKronigResult" title="pyimpspec.KramersKronigResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">KramersKronigResult</span></code></a> corresponding to the suggested number of RC elements.</p></li>
<li><p>A dictionary that maps the number of RC elements to their corresponding scores.</p></li>
<li><p>The lower limit for the number of RC elements to consider.</p></li>
<li><p>The upper limit for the number of RC elements to consider.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Tuple[<a class="reference internal" href="#pyimpspec.KramersKronigResult" title="pyimpspec.KramersKronigResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">KramersKronigResult</span></code></a>, Dict[int, float], int, int]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyimpspec.analysis.kramers_kronig.suggest_num_RC_limits">
<span class="sig-prename descclassname"><span class="pre">pyimpspec.analysis.kramers_kronig.</span></span><span class="sig-name descname"><span class="pre">suggest_num_RC_limits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tests</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">limit_delta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyimpspec.analysis.kramers_kronig.suggest_num_RC_limits" title="Link to this definition"></a></dt>
<dd><p>Suggest lower and upper limits for the range of number of time constants where the optimal number of time constants should be looked for.
The lower limit is the point at which incrementing the number of time constants no longer significantly improves the fit.
The upper limit is suggested based on the mean distances between sign changes of the curvatures and when those drop below a threshold.</p>
<p>References:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://doi.org/10.1016/j.electacta.2024.144951">V. Yrjänä and J. Bobacka, 2024, Electrochim. Acta, 504, 144951</a></p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tests</strong> (List[<a class="reference internal" href="#pyimpspec.KramersKronigResult" title="pyimpspec.KramersKronigResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">KramersKronigResult</span></code></a>]) – The test results to evaluate.</p></li>
<li><p><strong>lower_limit</strong> (<em>int</em><em>, </em><em>optional</em>) – The lower limit to enforce if this value is greater than zero.
If this value is set to zero, then the lower limit is automatically estimated.
If this value is less than zero, then no lower limit is enforced.</p></li>
<li><p><strong>upper_limit</strong> (<em>int</em><em>, </em><em>optional</em>) – The upper limit to enforce if this value is greater than zero.
If this value is set to zero, then the upper limit is automatically estimated.
If this value is less than zero, then no upper limit is enforced.</p></li>
<li><p><strong>limit_delta</strong> (<em>int</em><em>, </em><em>optional</em>) – Alternative way of defining the upper limit as lower limit + delta.
Only used if the value is greater than zero.</p></li>
<li><p><strong>threshold</strong> (<em>float</em><em>, </em><em>optional</em>) – The threshold for the mean distance between curvature sign changes.
This value is used when estimating the upper limit.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The suggested lower and upper limits for the number of RC elements where the optimal number of RC elements is likely to exist. Values outside these limits are likely to result in under- or overfitting.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Tuple[int, int]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyimpspec.analysis.kramers_kronig.suggest_representation">
<span class="sig-prename descclassname"><span class="pre">pyimpspec.analysis.kramers_kronig.</span></span><span class="sig-name descname"><span class="pre">suggest_representation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">suggestions</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyimpspec.analysis.kramers_kronig.suggest_representation" title="Link to this definition"></a></dt>
<dd><p>Suggest the most appropriate representation (impedance or admittance) of the immittance spectrum that was tested.
If the difference between <span class="math notranslate nohighlight">\(\chi^2_{\rm ps}\)</span> values is greater than 0.5 decades, then the representation that provides the best fit is picked.
Otherwise, the representations are scored according to various criteria:</p>
<ul class="simple">
<li><p>One point to whichever has the lowest number of RC elements.</p></li>
<li><p>One point to whichever has the lowest lower limit for the number of RC elements.</p></li>
<li><p>One point to whichever comes closest to having the imaginary part of each frequency extreme reach zero.</p></li>
</ul>
<p>The tuple in the input list that corresponds to the representation with the highest score is returned.</p>
<p>References:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://doi.org/10.1016/j.electacta.2024.144951">V. Yrjänä and J. Bobacka, 2024, Electrochim. Acta, 504, 144951</a></p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>suggestions</strong> (List[Tuple[<a class="reference internal" href="#pyimpspec.KramersKronigResult" title="pyimpspec.KramersKronigResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">KramersKronigResult</span></code></a>, Dict[int, float], int, int]]) – A list obtained by processing List[<a class="reference internal" href="#pyimpspec.KramersKronigResult" title="pyimpspec.KramersKronigResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">KramersKronigResult</span></code></a>] for different representations with <a class="reference internal" href="#pyimpspec.analysis.kramers_kronig.suggest_num_RC" title="pyimpspec.analysis.kramers_kronig.suggest_num_RC"><code class="xref py py-func docutils literal notranslate"><span class="pre">suggest_num_RC()</span></code></a> and collecting the return values.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p>A tuple containing:</p>
<ul class="simple">
<li><p>The <a class="reference internal" href="#pyimpspec.KramersKronigResult" title="pyimpspec.KramersKronigResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">KramersKronigResult</span></code></a> corresponding to the suggested number of RC elements and representation.</p></li>
<li><p>A dictionary that maps the number of RC elements to their corresponding scores for the suggested representation.</p></li>
<li><p>The lower limit for the number of RC elements to consider for the suggested representation.</p></li>
<li><p>The upper limit for the number of RC elements to consider for the suggested representation.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Tuple[<a class="reference internal" href="#pyimpspec.KramersKronigResult" title="pyimpspec.KramersKronigResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">KramersKronigResult</span></code></a>, Dict[int, float], int, int]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function" id="module-pyimpspec.analysis.kramers_kronig.algorithms">
<dt class="sig sig-object py" id="pyimpspec.analysis.kramers_kronig.algorithms.suggest_num_RC_method_1">
<span class="sig-prename descclassname"><span class="pre">pyimpspec.analysis.kramers_kronig.algorithms.</span></span><span class="sig-name descname"><span class="pre">suggest_num_RC_method_1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tests</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu_criterion</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.85</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.75</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">relative_scores</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyimpspec.analysis.kramers_kronig.algorithms.suggest_num_RC_method_1" title="Link to this definition"></a></dt>
<dd><p>The value <span class="math notranslate nohighlight">\(\mu\)</span> describes the ratio of the total mass of negative resistances to the total mass of positive resistances:</p>
<p><span class="math notranslate nohighlight">\(\mu = 1 - \frac{\Sigma_{R_k &lt; 0} |R_k|}{\Sigma_{R_k \geq 0} |R_k|}\)</span></p>
<p><span class="math notranslate nohighlight">\(\mu\)</span> ranges from 0.0 to 1.0 and these extremes represent overfitting and underfitting, respectively.
Overfitting manifests as an oscillating fitted impedance spectrum, which is made possible by a mix of positive and negative resistances.
The number of RC elements is incremented until the corresponding <span class="math notranslate nohighlight">\(\mu\)</span> drops below the threshold <span class="math notranslate nohighlight">\(\mu_{\rm crit}\)</span>.</p>
<p>The first modification is to adapt the equation above for use with validation of immittance data in the admittance representation:</p>
<p><span class="math notranslate nohighlight">\(\mu = 1 - \frac{\Sigma_{C_k &lt; 0} |C_k|}{\Sigma_{C_k \geq 0} |C_k|}\)</span></p>
<p>The denominator can be less than one, so the calculated values are clamped to only range from 0.0 to 1.0.</p>
<p>The second modification is that the iteration is done in reverse (i.e., by decrementing the number of RC elements instead of incrementing it) since there can be significant fluctuation of <span class="math notranslate nohighlight">\(\mu\)</span> at low numbers of RC elements, which can cause the iterative process to stop too early.</p>
<p>The third modification is to calculate an additional score, <span class="math notranslate nohighlight">\(S\)</span>, as follows:</p>
<p><span class="math notranslate nohighlight">\(S = \frac{-\log{\chi^2_{\rm ps}}}{{\left(\mu_{\rm crit} - \mu\right)}^{\beta}}\)</span></p>
<p>The exponent <span class="math notranslate nohighlight">\(\beta\)</span> is determined heuristically and a value of 0.75 seems to work well.
Only <span class="math notranslate nohighlight">\(\mu\)</span> values less than <span class="math notranslate nohighlight">\(\mu_{\rm crit}\)</span> are considered when calculating <span class="math notranslate nohighlight">\(S\)</span>.
The use of this score helps to deal with the fluctuation that affects the use of <span class="math notranslate nohighlight">\(\mu\)</span> directly.
If <span class="math notranslate nohighlight">\(\beta\)</span> is set to zero, then the second and third modification are skipped.</p>
<p>If <span class="math notranslate nohighlight">\(\mu\)</span> is negative, then an alternative approach is used whereby a logistic function is fitted to a plot of <span class="math notranslate nohighlight">\(\mu\)</span> versus the number of RC elements.
The intercept (rounded up) of the slope at the midpoint of that function and a line at the highest point of the function is used to pick the optimal number of RC elements.</p>
<p>The returned dictionary maps the number of RC elements to a score ranging from 0.0 to 1.0 with the latter representing the highest-ranking candidate.</p>
<p>References:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://doi.org/10.1016/j.electacta.2014.01.034">M. Schönleber, D. Klotz, and E. Ivers-Tiffée, 2014, Electrochim. Acta, 131, 20-27</a></p></li>
<li><p><a class="reference external" href="https://doi.org/10.1016/j.electacta.2024.144951">V. Yrjänä and J. Bobacka, 2024, Electrochim. Acta, 504, 144951</a></p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tests</strong> (List[<a class="reference internal" href="#pyimpspec.KramersKronigResult" title="pyimpspec.KramersKronigResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">KramersKronigResult</span></code></a>]) – The test results to evaluate.</p></li>
<li><p><strong>lower_limit</strong> (<em>int</em><em>, </em><em>optional</em>) – The lower limit to enforce for the number of RC elements.
If this value is less than one, then no limit is enforced.
If both the lower and upper limit are greater than zero, then the lower limit must have a smaller value than the upper limit.</p></li>
<li><p><strong>upper_limit</strong> (<em>int</em><em>, </em><em>optional</em>) – The upper limit to enforce for the number of RC elements.
If this value is less than one, then no limit is enforced.
If both the lower and upper limit are greater than zero, then the upper limit must have a greater value than the lower limit.</p></li>
<li><p><strong>mu_criterion</strong> (<em>float</em><em>, </em><em>optional</em>) – The <span class="math notranslate nohighlight">\(\mu_{\rm crit}\)</span> to apply.
Schönleber et al. (2014) recommended 0.85 based on their experiences.
If a value less than zero is provided, then the alternative approach based on fitting a logistic function to pick the optimal number of RC elements is used.</p></li>
<li><p><strong>beta</strong> (<em>float</em><em>, </em><em>optional</em>) – Exponent used to tweak the influence of the proximity of <span class="math notranslate nohighlight">\(\mu\)</span> to <span class="math notranslate nohighlight">\(\mu_{\rm crit}\)</span> when calculating scores.
If set to zero, then the iteration direction is not reversed and the score <span class="math notranslate nohighlight">\(S\)</span> is not calculated.</p></li>
<li><p><strong>relative_scores</strong> (<em>bool</em><em>, </em><em>optional</em>) – Return relative scores ranging from 0.0 to 1.0 (from worst to best) rather than the raw values.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A dictionary mapping the number of RC elements to its corresponding score.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Dict[int, float]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyimpspec.analysis.kramers_kronig.algorithms.suggest_num_RC_method_2">
<span class="sig-prename descclassname"><span class="pre">pyimpspec.analysis.kramers_kronig.algorithms.</span></span><span class="sig-name descname"><span class="pre">suggest_num_RC_method_2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tests</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">relative_scores</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyimpspec.analysis.kramers_kronig.algorithms.suggest_num_RC_method_2" title="Link to this definition"></a></dt>
<dd><p>Suggest the optimal number of RC elements to use based on the norm of the fitted variables divided by the number of RC elements.
Growing norms are used as indications of underfitting and overfitting.
Thus, a minimum of the norm of the fitted variables should coincide with the desired optimum.</p>
<p>References:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://doi.org/10.1109/IWIS57888.2022.9975131">C. Plank, T. Rüther, and M.A. Danzer, 2022, 2022 International Workshop on Impedance Spectroscopy (IWIS), 1-6</a></p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tests</strong> (List[<a class="reference internal" href="#pyimpspec.KramersKronigResult" title="pyimpspec.KramersKronigResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">KramersKronigResult</span></code></a>]) – The test results to evaluate.</p></li>
<li><p><strong>lower_limit</strong> (<em>int</em><em>, </em><em>optional</em>) – The lower limit to enforce for the number of RC elements.
If this value is less than one, then no limit is enforced.
If both the lower and upper limit are greater than zero, then the lower limit must have a smaller value than the upper limit.</p></li>
<li><p><strong>upper_limit</strong> (<em>int</em><em>, </em><em>optional</em>) – The upper limit to enforce for the number of RC elements.
If this value is less than one, then no limit is enforced.
If both the lower and upper limit are greater than zero, then the upper limit must have a greater value than the lower limit.</p></li>
<li><p><strong>relative_scores</strong> (<em>bool</em><em>, </em><em>optional</em>) – Return relative scores ranging from 0.0 to 1.0 (from worst to best) rather than the raw values.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A dictionary mapping the number of RC elements to its corresponding score.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Dict[int, float]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyimpspec.analysis.kramers_kronig.algorithms.suggest_num_RC_method_3">
<span class="sig-prename descclassname"><span class="pre">pyimpspec.analysis.kramers_kronig.algorithms.</span></span><span class="sig-name descname"><span class="pre">suggest_num_RC_method_3</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tests</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subdivision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subdivided_frequencies</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">curvatures</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">relative_scores</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyimpspec.analysis.kramers_kronig.algorithms.suggest_num_RC_method_3" title="Link to this definition"></a></dt>
<dd><p>Suggest the optimal number of RC elements to use based on the norm of the curvatures of the fitted impedance spectrum.
The curvatures at each point of the fitted impedance spectrum is approximated using an osculating circle.
A minimum of the norm of these curvatures should coincide with the desired optimum.</p>
<p>A modification whereby the frequency intervals are subdivided before determining curvatures is used to make the method less prone to suggesting circuits that produce oscillating impedance spectra.
This modified approach is used by default, but the original approach can be used by setting <code class="docutils literal notranslate"><span class="pre">subdivision</span> <span class="pre">=</span> <span class="pre">0</span></code>.</p>
<p>References:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://doi.org/10.1109/IWIS57888.2022.9975131">C. Plank, T. Rüther, and M.A. Danzer, 2022, 2022 International Workshop on Impedance Spectroscopy (IWIS), 1-6</a></p></li>
<li><p><a class="reference external" href="https://doi.org/10.1016/j.electacta.2024.144951">V. Yrjänä and J. Bobacka, 2024, Electrochim. Acta, 504, 144951</a></p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tests</strong> (List[<a class="reference internal" href="#pyimpspec.KramersKronigResult" title="pyimpspec.KramersKronigResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">KramersKronigResult</span></code></a>]) – The test results to evaluate.</p></li>
<li><p><strong>lower_limit</strong> (<em>int</em><em>, </em><em>optional</em>) – The lower limit to enforce for the number of RC elements.
If this value is less than one, then no limit is enforced.
If both the lower and upper limit are greater than zero, then the lower limit must have a smaller value than the upper limit.</p></li>
<li><p><strong>upper_limit</strong> (<em>int</em><em>, </em><em>optional</em>) – The upper limit to enforce for the number of RC elements.
If this value is less than one, then no limit is enforced.
If both the lower and upper limit are greater than zero, then the upper limit must have a greater value than the lower limit.</p></li>
<li><p><strong>subdivision</strong> (<em>int</em><em>, </em><em>optional</em>) – If greater than zero, then that number of additional frequencies are inserted into each frequency interval.</p></li>
<li><p><strong>subdivided_frequencies</strong> (<em>Optional</em><em>[</em><em>Frequencies</em><em>]</em><em>, </em><em>optional</em>) – Frequencies that have already been subdivided. If multiple methods that require subdividing frequencies will be used, then this provides a means of reusing those frequencies.</p></li>
<li><p><strong>curvatures</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>int</em><em>, </em><em>NDArray</em><em>[</em><em>float64</em><em>]</em><em>]</em><em>]</em><em>, </em><em>optional</em>) – Curvatures that have already been estimated. If multiple methods that require curvatures will be used, then this provides a means of reusing those curvatures.</p></li>
<li><p><strong>relative_scores</strong> (<em>bool</em><em>, </em><em>optional</em>) – Return relative scores ranging from 0.0 to 1.0 (from worst to best) rather than the raw values.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A dictionary mapping the number of RC elements to its corresponding score.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Dict[int, float]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyimpspec.analysis.kramers_kronig.algorithms.suggest_num_RC_method_4">
<span class="sig-prename descclassname"><span class="pre">pyimpspec.analysis.kramers_kronig.algorithms.</span></span><span class="sig-name descname"><span class="pre">suggest_num_RC_method_4</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tests</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subdivision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subdivided_frequencies</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">curvatures</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">relative_scores</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyimpspec.analysis.kramers_kronig.algorithms.suggest_num_RC_method_4" title="Link to this definition"></a></dt>
<dd><p>Suggest the optimal number of RC elements to use based on the number of sign changes of curvatures of the fitted impedance spectrum.
The curvatures at each point of the fitted impedance spectrum is approximated using an osculating circle.
An increasing number of sign changes of these curvatures results from oscillations brought on by overfitting.
Thus, a minimum of the number of sign changes should coincide with the desired optimum.</p>
<p>The method is modified by subdividing the frequency intervals, which makes the method less prone to suggesting circuits that produce oscillating impedance spectra.
Small offsets are also added to the number of sign changes based on the corresponding pseudo chi-squared values in order to act as tiebreakers in case there are multiple numbers of RC elements that correspond to the same number of sign changes.
This modified approach is used by default, but the original approach can be used by setting <code class="docutils literal notranslate"><span class="pre">subdivision</span> <span class="pre">=</span> <span class="pre">0</span></code> and <code class="docutils literal notranslate"><span class="pre">offset_factor</span> <span class="pre">=</span> <span class="pre">0.0</span></code>.</p>
<p>References:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://doi.org/10.1109/IWIS57888.2022.9975131">C. Plank, T. Rüther, and M.A. Danzer, 2022, 2022 International Workshop on Impedance Spectroscopy (IWIS), 1-6</a></p></li>
<li><p><a class="reference external" href="https://doi.org/10.1016/j.electacta.2024.144951">V. Yrjänä and J. Bobacka, 2024, Electrochim. Acta, 504, 144951</a></p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tests</strong> (List[<a class="reference internal" href="#pyimpspec.KramersKronigResult" title="pyimpspec.KramersKronigResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">KramersKronigResult</span></code></a>]) – The test results to evaluate.</p></li>
<li><p><strong>lower_limit</strong> (<em>int</em><em>, </em><em>optional</em>) – The lower limit to enforce for the number of RC elements.
If this value is less than one, then no limit is enforced.
If both the lower and upper limit are greater than zero, then the lower limit must have a smaller value than the upper limit.</p></li>
<li><p><strong>upper_limit</strong> (<em>int</em><em>, </em><em>optional</em>) – The upper limit to enforce for the number of RC elements.
If this value is less than one, then no limit is enforced.
If both the lower and upper limit are greater than zero, then the upper limit must have a greater value than the lower limit.</p></li>
<li><p><strong>subdivision</strong> (<em>int</em><em>, </em><em>optional</em>) – If greater than zero, then that number of additional frequencies are inserted into each frequency interval.</p></li>
<li><p><strong>subdivided_frequencies</strong> (<em>Optional</em><em>[</em><em>Frequencies</em><em>]</em><em>, </em><em>optional</em>) – Frequencies that have already been subdivided. If multiple methods that require subdividing frequencies will be used, then this provides a means of reusing those frequencies.</p></li>
<li><p><strong>curvatures</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>int</em><em>, </em><em>NDArray</em><em>[</em><em>float64</em><em>]</em><em>]</em><em>]</em><em>, </em><em>optional</em>) – Curvatures that have already been estimated. If multiple methods that require curvatures will be used, then this provides a means of reusing those curvatures.</p></li>
<li><p><strong>offset_factor</strong> (<em>float</em><em>, </em><em>optional</em>) – The factor that an offset is multiplied by when it is being added to a number of sign changes.
Must be in the range [0.0, 1.0).</p></li>
<li><p><strong>relative_scores</strong> (<em>bool</em><em>, </em><em>optional</em>) – Return relative scores ranging from 0.0 to 1.0 (from worst to best) rather than the raw values.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A dictionary mapping the number of RC elements to its corresponding score.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Dict[int, float]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyimpspec.analysis.kramers_kronig.algorithms.suggest_num_RC_method_5">
<span class="sig-prename descclassname"><span class="pre">pyimpspec.analysis.kramers_kronig.algorithms.</span></span><span class="sig-name descname"><span class="pre">suggest_num_RC_method_5</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tests</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subdivision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subdivided_frequencies</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">curvatures</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">relative_scores</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyimpspec.analysis.kramers_kronig.algorithms.suggest_num_RC_method_5" title="Link to this definition"></a></dt>
<dd><p>Suggest the optimal number of RC elements to use based on the average distance between sign changes of the curvatures of the fitted impedance spectrum.
The curvatures at each point of the fitted impedance spectrum is approximated using an osculating circle.
The largest average distance should occur at the lowest number of RC elements, but the optimum coincides with a local maximum at an intermediate number of RC elements.
The average distance will tend towards one as the number of RC elements is incremented further.</p>
<p>References:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://doi.org/10.1016/j.electacta.2024.144951">V. Yrjänä and J. Bobacka, 2024, Electrochim. Acta, 504, 144951</a></p></li>
<li><p><a class="reference external" href="https://doi.org/10.1109/IWIS57888.2022.9975131">C. Plank, T. Rüther, and M.A. Danzer, 2022, 2022 International Workshop on Impedance Spectroscopy (IWIS), 1-6</a></p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tests</strong> (List[<a class="reference internal" href="#pyimpspec.KramersKronigResult" title="pyimpspec.KramersKronigResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">KramersKronigResult</span></code></a>]) – The test results to evaluate.</p></li>
<li><p><strong>lower_limit</strong> (<em>int</em><em>, </em><em>optional</em>) – The lower limit to enforce for the number of RC elements.
If this value is less than one, then no limit is enforced.
If both the lower and upper limit are greater than zero, then the lower limit must have a smaller value than the upper limit.</p></li>
<li><p><strong>upper_limit</strong> (<em>int</em><em>, </em><em>optional</em>) – The upper limit to enforce for the number of RC elements.
If this value is less than one, then no limit is enforced.
If both the lower and upper limit are greater than zero, then the upper limit must have a greater value than the lower limit.</p></li>
<li><p><strong>subdivision</strong> (<em>int</em><em>, </em><em>optional</em>) – If greater than zero, then that number of additional frequencies are inserted into each frequency interval.</p></li>
<li><p><strong>subdivided_frequencies</strong> (<em>Optional</em><em>[</em><em>Frequencies</em><em>]</em><em>, </em><em>optional</em>) – Frequencies that have already been subdivided. If multiple methods that require subdividing frequencies will be used, then this provides a means of reusing those frequencies.</p></li>
<li><p><strong>curvatures</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><em>int</em><em>, </em><em>NDArray</em><em>[</em><em>float64</em><em>]</em><em>]</em><em>]</em><em>, </em><em>optional</em>) – Curvatures that have already been estimated. If multiple methods that require curvatures will be used, then this provides a means of reusing those curvatures.</p></li>
<li><p><strong>relative_scores</strong> (<em>bool</em><em>, </em><em>optional</em>) – Return relative scores ranging from 0.0 to 1.0 (from worst to best) rather than the raw values.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A dictionary mapping the number of RC elements to its corresponding score.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Dict[int, float]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyimpspec.analysis.kramers_kronig.algorithms.suggest_num_RC_method_6">
<span class="sig-prename descclassname"><span class="pre">pyimpspec.analysis.kramers_kronig.algorithms.</span></span><span class="sig-name descname"><span class="pre">suggest_num_RC_method_6</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tests</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">relative_scores</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyimpspec.analysis.kramers_kronig.algorithms.suggest_num_RC_method_6" title="Link to this definition"></a></dt>
<dd><p>Suggest the optimal number of RC elements to use based on the approximate position of the apex in a plot of <span class="math notranslate nohighlight">\(\log{\Sigma_{k=1}^{N_\tau} |\tau_k / R_k|}\)</span> versus the number of RC elements.
If the tests were performed on the admittance representation of the immittance data, then <span class="math notranslate nohighlight">\(C_k\)</span> is substituted for <span class="math notranslate nohighlight">\(R_k\)</span>.
The sum grows initially as the number of RC elements increases.
However, the magnitudes of the fitted <span class="math notranslate nohighlight">\(R_k\)</span> (or <span class="math notranslate nohighlight">\(C_k\)</span>) also tend to increase, which causes the magnitudes of the corresponding <span class="math notranslate nohighlight">\(C_k\)</span> (or <span class="math notranslate nohighlight">\(R_k\)</span>) to decrease.
Thus, the sum begins to decline despite the increasing number of RC elements and the fitted impedance spectrum begins to oscillate (i.e., overfitting takes place).
The apex should coincide with or be near the optimum.</p>
<p>References:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://doi.org/10.1016/j.electacta.2024.144951">V. Yrjänä and J. Bobacka, 2024, Electrochim. Acta, 504, 144951</a></p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tests</strong> (List[<a class="reference internal" href="#pyimpspec.KramersKronigResult" title="pyimpspec.KramersKronigResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">KramersKronigResult</span></code></a>]) – The test results to evaluate.</p></li>
<li><p><strong>lower_limit</strong> (<em>int</em><em>, </em><em>optional</em>) – The lower limit to enforce for the number of RC elements.
If this value is less than one, then no limit is enforced.
If both the lower and upper limit are greater than zero, then the lower limit must have a smaller value than the upper limit.</p></li>
<li><p><strong>upper_limit</strong> (<em>int</em><em>, </em><em>optional</em>) – The upper limit to enforce for the number of RC elements.
If this value is less than one, then no limit is enforced.
If both the lower and upper limit are greater than zero, then the upper limit must have a greater value than the lower limit.</p></li>
<li><p><strong>relative_scores</strong> (<em>bool</em><em>, </em><em>optional</em>) – Return relative scores ranging from 0.0 to 1.0 (from worst to best) rather than the raw values.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A dictionary mapping the number of RC elements to its corresponding score.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Dict[int, float]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function" id="module-pyimpspec.analysis.kramers_kronig.algorithms.utility">
<dt class="sig sig-object py" id="pyimpspec.analysis.kramers_kronig.algorithms.utility.calculate_curvatures">
<span class="sig-prename descclassname"><span class="pre">pyimpspec.analysis.kramers_kronig.algorithms.utility.</span></span><span class="sig-name descname"><span class="pre">calculate_curvatures</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Z</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyimpspec.analysis.kramers_kronig.algorithms.utility.calculate_curvatures" title="Link to this definition"></a></dt>
<dd><p>Estimate the curvatures of an impedance spectrum.</p>
<p>References:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://doi.org/10.1109/IWIS57888.2022.9975131">C. Plank, T. Rüther, and M.A. Danzer, 2022, 2022 International Workshop on Impedance Spectroscopy (IWIS), 1-6</a></p></li>
<li><p><a class="reference external" href="https://doi.org/10.1016/j.electacta.2024.144951">V. Yrjänä and J. Bobacka, 2024, Electrochim. Acta, 504, 144951</a></p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>Z</strong> (<em>ComplexImpedances</em>) – The impedances to use when estimating the curvatures using osculating circles.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An array of curvatures.
If the impedances were sorted in order of decreasing frequency, then a curvature with a negative sign indicates a clockwise motion within the context of a plot of <span class="math notranslate nohighlight">\(-{\rm Im}(Z)\ {\rm versus}\ {\rm Re}(Z)\)</span>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>NDArray[float64]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pyimpspec.analysis.kramers_kronig.algorithms.utility.subdivide_frequencies">
<span class="sig-prename descclassname"><span class="pre">pyimpspec.analysis.kramers_kronig.algorithms.utility.</span></span><span class="sig-name descname"><span class="pre">subdivide_frequencies</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frequencies</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subdivision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyimpspec.analysis.kramers_kronig.algorithms.utility.subdivide_frequencies" title="Link to this definition"></a></dt>
<dd><p>Insert additional frequencies between each pair of frequencies.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frequencies</strong> (<em>Frequencies</em>) – The original frequencies that are to be subdivided.</p></li>
<li><p><strong>subdivision</strong> (<em>int</em><em>, </em><em>optional</em>) – The number of frequencies added between each of the original frequencies.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A new set of frequencies with additional frequencies inserted between each of the original frequencies.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Frequencies</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-1">
<span id="class"></span><h2>Class<a class="headerlink" href="#module-1" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pyimpspec.KramersKronigResult">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pyimpspec.</span></span><span class="sig-name descname"><span class="pre">KramersKronigResult</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">circuit</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pseudo_chisqr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frequencies</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">impedances</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">residuals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">test</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyimpspec.KramersKronigResult" title="Link to this definition"></a></dt>
<dd><p>An object representing the results of a linear Kramers-Kronig test applied to a data set.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>circuit</strong> (<a class="reference internal" href="apidocs_circuit.html#pyimpspec.Circuit" title="pyimpspec.Circuit"><em>Circuit</em></a>) – The fitted circuit.</p></li>
<li><p><strong>pseudo_chisqr</strong> (<em>float</em>) – The pseudo chi-squared value (<span class="math notranslate nohighlight">\(\chi^2_{\rm ps}\)</span>, eq. 14 in Boukamp, 1995).</p></li>
<li><p><strong>frequencies</strong> (<a class="reference internal" href="apidocs_typing.html#pyimpspec.Frequencies" title="pyimpspec.Frequencies"><code class="xref py py-class docutils literal notranslate"><span class="pre">Frequencies</span></code></a>) – The frequencies used to perform the test.</p></li>
<li><p><strong>impedances</strong> (<a class="reference internal" href="apidocs_typing.html#pyimpspec.ComplexImpedances" title="pyimpspec.ComplexImpedances"><code class="xref py py-class docutils literal notranslate"><span class="pre">ComplexImpedances</span></code></a>) – The impedances produced by the fitted circuit at each of the tested frequencies.</p></li>
<li><p><strong>residuals</strong> (<a class="reference internal" href="apidocs_typing.html#pyimpspec.ComplexResiduals" title="pyimpspec.ComplexResiduals"><code class="xref py py-class docutils literal notranslate"><span class="pre">ComplexResiduals</span></code></a>) – The residuals for the real (eq. 15 in Schönleber et al., 2014) and imaginary (eq. 16 in Schönleber et al., 2014) parts of the fit.</p></li>
<li><p><strong>test</strong> (<em>str</em>) – <p>The type of test (and implementation) that was performed:</p>
<ul>
<li><p>’complex’</p></li>
<li><p>’real’</p></li>
<li><p>’imaginary’</p></li>
<li><p>’complex-inv’</p></li>
<li><p>’real-inv’</p></li>
<li><p>’imaginary-inv’</p></li>
<li><p>’cnls’</p></li>
</ul>
</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pyimpspec.KramersKronigResult.get_bode_data">
<span class="sig-name descname"><span class="pre">get_bode_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_per_decade</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyimpspec.KramersKronigResult.get_bode_data" title="Link to this definition"></a></dt>
<dd><p>Get the data necessary to plot this KramersKronigResult as a Bode plot: the frequencies, the absolute magnitudes of the impedances, and the negative phase angles/shifts of the impedances in degrees.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>num_per_decade</strong> (<em>int</em><em>, </em><em>optional</em>) – The number of points per decade.
A positive value results in data points being calculated using the fitted circuit within the original frequency range.
Otherwise, only the original frequencies are used.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>Tuple[<a class="reference internal" href="apidocs_typing.html#pyimpspec.Frequencies" title="pyimpspec.Frequencies"><code class="xref py py-class docutils literal notranslate"><span class="pre">Frequencies</span></code></a>, <a class="reference internal" href="apidocs_typing.html#pyimpspec.Impedances" title="pyimpspec.Impedances"><code class="xref py py-class docutils literal notranslate"><span class="pre">Impedances</span></code></a>, <a class="reference internal" href="apidocs_typing.html#pyimpspec.Phases" title="pyimpspec.Phases"><code class="xref py py-class docutils literal notranslate"><span class="pre">Phases</span></code></a>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyimpspec.KramersKronigResult.get_estimated_percent_noise">
<span class="sig-name descname"><span class="pre">get_estimated_percent_noise</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyimpspec.KramersKronigResult.get_estimated_percent_noise" title="Link to this definition"></a></dt>
<dd><p>Estimate the standard deviation of the noise (as a percentage of <span class="math notranslate nohighlight">\(|Z|\)</span>) using the approximation <span class="math notranslate nohighlight">\({\rm SD}_{\rm est} \approx \sqrt{\chi^2_{\rm ps} \times 5000 / N_\omega}\)</span> where <span class="math notranslate nohighlight">\(\chi^2_{\rm ps}\)</span> is the pseudo chi-squared value of the fit and <span class="math notranslate nohighlight">\(N_\omega\)</span> is the number of excitation frequencies. This approximation assumes that the error is spread evenly across the real and imaginary parts of the immittance spectrum.</p>
<p>References:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://doi.org/10.1016/j.electacta.2024.144951">V. Yrjänä and J. Bobacka, 2024, Electrochim. Acta, 504, 144951</a></p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyimpspec.KramersKronigResult.get_frequencies">
<span class="sig-name descname"><span class="pre">get_frequencies</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_per_decade</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyimpspec.KramersKronigResult.get_frequencies" title="Link to this definition"></a></dt>
<dd><p>Get the frequencies in the tested frequency range.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>num_per_decade</strong> (<em>int</em><em>, </em><em>optional</em>) – The number of points per decade.
A positive value results in frequencies being calculated within the original frequency range.
Otherwise, only the original frequencies are used.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="apidocs_typing.html#pyimpspec.Frequencies" title="pyimpspec.Frequencies"><code class="xref py py-class docutils literal notranslate"><span class="pre">Frequencies</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyimpspec.KramersKronigResult.get_impedances">
<span class="sig-name descname"><span class="pre">get_impedances</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_per_decade</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyimpspec.KramersKronigResult.get_impedances" title="Link to this definition"></a></dt>
<dd><p>Get the fitted circuit’s impedance response within the tested frequency range.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>num_per_decade</strong> (<em>int</em><em>, </em><em>optional</em>) – The number of points per decade.
A positive value results in data points being calculated using the fitted circuit within the original frequency range.
Otherwise, only the original frequencies are used.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="apidocs_typing.html#pyimpspec.ComplexImpedances" title="pyimpspec.ComplexImpedances"><code class="xref py py-class docutils literal notranslate"><span class="pre">ComplexImpedances</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyimpspec.KramersKronigResult.get_label">
<span class="sig-name descname"><span class="pre">get_label</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyimpspec.KramersKronigResult.get_label" title="Link to this definition"></a></dt>
<dd><p>Get the label of this result.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyimpspec.KramersKronigResult.get_log_F_ext">
<span class="sig-name descname"><span class="pre">get_log_F_ext</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyimpspec.KramersKronigResult.get_log_F_ext" title="Link to this definition"></a></dt>
<dd><p>Get the value of <span class="math notranslate nohighlight">\(\log{F_{\rm ext}}\)</span>, which affects the range of time constants.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyimpspec.KramersKronigResult.get_nyquist_data">
<span class="sig-name descname"><span class="pre">get_nyquist_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_per_decade</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyimpspec.KramersKronigResult.get_nyquist_data" title="Link to this definition"></a></dt>
<dd><p>Get the data necessary to plot this KramersKronigResult as a Nyquist plot: the real and the negative imaginary parts of the impedances.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>num_per_decade</strong> (<em>int</em><em>, </em><em>optional</em>) – The number of points per decade.
A positive value results in data points being calculated using the fitted circuit within the original frequency range.
Otherwise, only the original frequencies are used.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>Tuple[<a class="reference internal" href="apidocs_typing.html#pyimpspec.Impedances" title="pyimpspec.Impedances"><code class="xref py py-class docutils literal notranslate"><span class="pre">Impedances</span></code></a>, <a class="reference internal" href="apidocs_typing.html#pyimpspec.Impedances" title="pyimpspec.Impedances"><code class="xref py py-class docutils literal notranslate"><span class="pre">Impedances</span></code></a>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyimpspec.KramersKronigResult.get_parallel_capacitance">
<span class="sig-name descname"><span class="pre">get_parallel_capacitance</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyimpspec.KramersKronigResult.get_parallel_capacitance" title="Link to this definition"></a></dt>
<dd><p>Get the value of the parallel capacitance (or numpy.nan if not included in the circuit).</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyimpspec.KramersKronigResult.get_parallel_inductance">
<span class="sig-name descname"><span class="pre">get_parallel_inductance</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyimpspec.KramersKronigResult.get_parallel_inductance" title="Link to this definition"></a></dt>
<dd><p>Get the value of the parallel inductance (or numpy.nan if not included in the circuit).</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyimpspec.KramersKronigResult.get_parallel_resistance">
<span class="sig-name descname"><span class="pre">get_parallel_resistance</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyimpspec.KramersKronigResult.get_parallel_resistance" title="Link to this definition"></a></dt>
<dd><p>Get the value of the parallel resistance.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyimpspec.KramersKronigResult.get_residuals_data">
<span class="sig-name descname"><span class="pre">get_residuals_data</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyimpspec.KramersKronigResult.get_residuals_data" title="Link to this definition"></a></dt>
<dd><p>Get the data necessary to plot the relative residuals for this result: the frequencies, the relative residuals for the real parts of the impedances in percents, and the relative residuals for the imaginary parts of the impedances in percents.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Tuple[<a class="reference internal" href="apidocs_typing.html#pyimpspec.Frequencies" title="pyimpspec.Frequencies"><code class="xref py py-class docutils literal notranslate"><span class="pre">Frequencies</span></code></a>, <a class="reference internal" href="apidocs_typing.html#pyimpspec.Residuals" title="pyimpspec.Residuals"><code class="xref py py-class docutils literal notranslate"><span class="pre">Residuals</span></code></a>, <a class="reference internal" href="apidocs_typing.html#pyimpspec.Residuals" title="pyimpspec.Residuals"><code class="xref py py-class docutils literal notranslate"><span class="pre">Residuals</span></code></a>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyimpspec.KramersKronigResult.get_series_capacitance">
<span class="sig-name descname"><span class="pre">get_series_capacitance</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyimpspec.KramersKronigResult.get_series_capacitance" title="Link to this definition"></a></dt>
<dd><p>Get the value of the series capacitance (or numpy.nan if not included in the circuit).</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyimpspec.KramersKronigResult.get_series_inductance">
<span class="sig-name descname"><span class="pre">get_series_inductance</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyimpspec.KramersKronigResult.get_series_inductance" title="Link to this definition"></a></dt>
<dd><p>Get the value of the series inductance (or numpy.nan if not included in the circuit).</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyimpspec.KramersKronigResult.get_series_resistance">
<span class="sig-name descname"><span class="pre">get_series_resistance</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyimpspec.KramersKronigResult.get_series_resistance" title="Link to this definition"></a></dt>
<dd><p>Get the value of the series resistance.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyimpspec.KramersKronigResult.get_time_constants">
<span class="sig-name descname"><span class="pre">get_time_constants</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyimpspec.KramersKronigResult.get_time_constants" title="Link to this definition"></a></dt>
<dd><p>Get the time constants that were used during fitting.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="apidocs_typing.html#pyimpspec.TimeConstants" title="pyimpspec.TimeConstants"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeConstants</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyimpspec.KramersKronigResult.perform_kolmogorov_smirnov_test">
<span class="sig-name descname"><span class="pre">perform_kolmogorov_smirnov_test</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">standard_deviation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyimpspec.KramersKronigResult.perform_kolmogorov_smirnov_test" title="Link to this definition"></a></dt>
<dd><p>Perform one-sample Kolmogorov-Smirnov test on the residuals of the real and imaginary parts.
The residuals are tested against a normal distribution with a mean that is assumed to be zero and a standard deviation that can either be provided or estimated automatically.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>standard_deviation</strong> (<em>float</em><em>, </em><em>optional</em>) – If greater than zero, then the provided value is used.
Otherwise, the standard deviation estimated based on the pseudo chi-squared and the number of frequencies is used.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The p-values for the tests performed on the residuals of the real and imaginary parts.
The null hypothesis is that the distributions of the residuals are identical to the normal distribution with a mean of zero and the provided (or estimated) standard deviation.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Tuple[float, float]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyimpspec.KramersKronigResult.perform_lilliefors_test">
<span class="sig-name descname"><span class="pre">perform_lilliefors_test</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyimpspec.KramersKronigResult.perform_lilliefors_test" title="Link to this definition"></a></dt>
<dd><p>Perform the Lilliefors test for normality on the residuals of the real and imaginary parts.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The p-values for the tests performed on the residuals of the real and imaginary parts.
The null hypothesis is that the residuals come from a normal distribution.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>Tuple[float, float]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyimpspec.KramersKronigResult.perform_shapiro_wilk_test">
<span class="sig-name descname"><span class="pre">perform_shapiro_wilk_test</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pyimpspec.KramersKronigResult.perform_shapiro_wilk_test" title="Link to this definition"></a></dt>
<dd><p>Perform the Shapiro-Wilk test for normality on the residuals of the real and imaginary parts.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The p-values for the tests performed on the residuals of the real and imaginary parts.
The null hypothesis is that the residuals come from a normal distribution.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>Tuple[float, float]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pyimpspec.KramersKronigResult.to_statistics_dataframe">
<span class="sig-name descname"><span class="pre">to_statistics_dataframe</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">extended_statistics</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pyimpspec.KramersKronigResult.to_statistics_dataframe" title="Link to this definition"></a></dt>
<dd><p>Get the statistics related to the test as a <a class="reference external" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html#pandas.DataFrame">pandas.DataFrame</a> object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>extended_statistics</strong> (<em>int</em><em>, </em><em>optional</em>) – <p>Include different amounts of additional statistics depending on the chosen level.
Level 1 includes:</p>
<ul class="simple">
<li><p>The estimated equivalent standard deviation of a Gaussian noise calculated based on the pseudo chi-squared value assuming that the noise in the real and imaginary parts of the impedance are independent, have a Gaussian distribution, a mean of zero, and the same standard deviation.</p></li>
<li><p>The means of the real and imaginary residuals.</p></li>
<li><p>The sample standard deviations of the real and imaginary residuals.</p></li>
<li><p>The percentage of points found within 1, 2, or 3 standard deviations.</p></li>
</ul>
<p>Level 2 includes:</p>
<ul class="simple">
<li><p>The p-values of normality tests performed on the real or imaginary residuals. These tests include: Lilliefors and Shapiro-Wilk.</p></li>
</ul>
<p>Level 3 includes:</p>
<ul class="simple">
<li><p>The p-values for one-sample Kolmogorov-Smirnov tests comparing the real or imaginary residuals against a normal distribution with a mean of zero and a standard deviation (as a percentage of <span class="math notranslate nohighlight">\(|Z|\)</span>) equal to the approximation obtained with <span class="math notranslate nohighlight">\({\rm SD}_{\rm est} \approx \sqrt{\chi^2_{\rm ps} \times 5000 / N_\omega}\)</span> where <span class="math notranslate nohighlight">\(\chi^2_{\rm ps}\)</span> is the pseudo chi-squared value of the fit and <span class="math notranslate nohighlight">\(N_\omega\)</span> is the number of excitation frequencies. This approximation assumes that the error is spread evenly across the real and imaginary parts of the immittance spectrum.</p></li>
</ul>
</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html#pandas.DataFrame">pandas.DataFrame</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="apidocs_mock_data.html" class="btn btn-neutral float-left" title="Mock data" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="apidocs_zhit.html" class="btn btn-neutral float-right" title="Z-HIT analysis" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, pyimpspec developers.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>